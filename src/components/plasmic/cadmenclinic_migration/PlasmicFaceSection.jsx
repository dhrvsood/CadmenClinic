/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/* prettier-ignore-start */
/** @jsxRuntime classic */
/** @jsx createPlasmicElementProxy */
/** @jsxFrag React.Fragment */
// This class is auto-generated by Plasmic; please do not edit!
// Plasmic Project: fpxTiFS69ULcX4wDGEfw3c
// Component: dOVgE0OgS0yG
import * as React from "react";
import { useRouter } from "next/router";
import {
  PlasmicImg as PlasmicImg__,
  Stack as Stack__,
  classNames,
  createPlasmicElementProxy,
  deriveRenderOpts,
  ensureGlobalVariants,
  get as $stateGet,
  hasVariant,
  set as $stateSet,
  useDollarState
} from "@plasmicapp/react-web";
import { useDataEnv } from "@plasmicapp/react-web/lib/host";
import SelectPill from "../../SelectPill"; // plasmic-import: XgOD49Zg0vP7/component
import FaceDot from "../../FaceDot"; // plasmic-import: B4gD5jrIlb5E/component
import AreaCard from "../../AreaCard"; // plasmic-import: pX5xJXaiuz4K/component
import { AntdButton } from "@plasmicpkgs/antd5/skinny/registerButton";
import { useScreenVariants as useScreenVariants_4IUcgkiijTv2 } from "../blank_website/PlasmicGlobalVariant__Screen"; // plasmic-import: 4iUCGKIIJTv2/globalVariant
import "@plasmicapp/react-web/lib/plasmic.css";
import plasmic_antd_5_hostless_css from "../antd_5_hostless/plasmic.module.css"; // plasmic-import: ohDidvG9XsCeFumugENU3J/projectcss
import projectcss from "../blank_website/plasmic.module.css"; // plasmic-import: fpxTiFS69ULcX4wDGEfw3c/projectcss
import sty from "./PlasmicFaceSection.module.css"; // plasmic-import: dOVgE0OgS0yG/css

createPlasmicElementProxy;

export const PlasmicFaceSection__VariantProps = new Array();

export const PlasmicFaceSection__ArgProps = new Array("items", "selectedArea");

const $$ = {};

function useNextRouter() {
  try {
    return useRouter();
  } catch {}
  return undefined;
}

function PlasmicFaceSection__RenderFunc(props) {
  const { variants, overrides, forNode } = props;
  const args = React.useMemo(
    () =>
      Object.assign(
        {
          items: [
            {
              name: "Forehead",
              nameDescription: "",
              content:
                "Reduces horizontal lines across\nthe forehead for a smoother look.",
              face_dot: { left: "53.23%", top: "11.67%" },
              range: "$100 - $200",
              units: "10-20 units"
            },
            {
              name: "Crow\u2019s Feet",
              nameDescription: "",
              content:
                "Smooths the fine lines that form\naround the outer corners of the eyes.",
              face_dot: { left: "29.85%", top: "38.94%" },
              range: "$50 - $150",
              units: "5-15 units"
            },
            {
              name: "Hooded Eyes",
              nameDescription: "",
              content:
                "Lifts and opens up the appearance\nof drooping eyelids.",
              face_dot: { left: "34.46%", top: "31.52%" },
              range: "$100 - $200",
              units: "10-20 units"
            },
            {
              name: "Jawline",
              nameDescription: "",
              content:
                "Helps contour and refine the jawline\nfor a more sculpted appearance.",
              face_dot: { left: "37.85%", top: "66.67%" },
              range: "$100 - $200",
              units: "10-20 units"
            },
            {
              name: "Under Eye Wrinkles",
              nameDescription: "",
              content: "Minimizes fine lines and wrinkles beneath\nthe eyes.",
              face_dot: { left: "44.62%", top: "41.36%" },
              range: "$100 - $200",
              units: "10-20 units"
            },
            {
              name: "Turkey Neck",
              nameDescription: "",
              content:
                "Tightens and smooths sagging skin\nalong the neck area.",
              face_dot: { left: "55.85%", top: "88.03%" },
              range: "$100 - $200",
              units: "10-20 units"
            },
            {
              name: "Bruxism",
              nameDescription: "",
              content: "Eases teeth grinding by relaxing\nthe jaw muscles.",
              face_dot: { left: "66.92%", top: "78.33%" },
              range: "$100 - $200",
              units: "10-20 units"
            },
            {
              name: "Frown Lines",
              nameDescription: "",
              content:
                "Softens vertical lines between the brows,\noften referred to as '11 lines.",
              face_dot: { left: "54.15%", top: "25.30%" },
              range: "$200 - $300",
              units: "20-30 units"
            },
            {
              name: "Jaw Clenching",
              nameDescription: "",
              content:
                "Reduces the strain on jaw muscles,\nalleviating tension and pain.",
              face_dot: { left: "62.62%", top: "56.97%" },
              range: "$100 - $200",
              units: "10-20 units"
            },
            {
              name: "TMJ",
              nameDescription: "(Temporomandibular Joint Disorders)",
              content:
                "(Temporomandibular Joint Disorders)\nRelieves tension and discomfort caused\nby jaw clenching and grinding.",
              face_dot: { left: "69.54%", top: "65.00%" },
              range: "$100 - $200",
              units: "10-20 units"
            },
            {
              name: "Jowls",
              nameDescription: "",
              content:
                "Lifts and tightens sagging skin along\nthe jawline for a more defined look.",
              face_dot: { left: "70.31%", top: "56.97%" },
              range: "$50 - $100",
              units: "5-10 units"
            },
            {
              name: "Headaches",
              nameDescription: "",
              content:
                "Provides relief from chronic migraines\nand tension headaches.",
              face_dot: { left: "77.54%", top: "21.06%" },
              range: "$100 - $200",
              units: "10-20 units"
            },
            {
              name: "Smile Lines",
              nameDescription: "",
              content:
                "Softens the creases that form around\nthe mouth when smiling.",
              face_dot: { left: "36.92%", top: "56.97%" },
              range: "$50 - $100",
              units: "5-10 units"
            },
            {
              name: "Gummy Smile",
              nameDescription: "",
              content:
                "Minimizes the appearance of excessive\ngum tissue when smiling.",
              face_dot: { left: "62.62%", top: "71.67%" },
              range: "$100",
              units: "Varies"
            },
            {
              name: "Double Chin",
              nameDescription: "",
              content:
                "Slims the neck area by relaxing muscles\ncontributing to a fuller chin.",
              face_dot: { left: "54.15%", top: "79.85%" },
              range: "$40 - $100",
              units: "4-10 units"
            },
            {
              name: "Under Eye Bags",
              nameDescription: "",
              content:
                "Smooths the appearance of puffiness\nand fine lines under the eyes.",
              face_dot: { left: "68.62%", top: "41.52%" },
              range: "$100 - $200",
              units: "10-20 units"
            },
            {
              name: "Hyperhidrosis",
              nameDescription: "",
              content:
                "Effectively reduces excessive sweating,\nparticularly in the underarms, hands, or feet.",
              face_dot: { left: "79.23%", top: "91.82%" },
              range: "$100 - $200",
              units: "10-20 units"
            },
            {
              name: "Sweating",
              nameDescription: "",
              content: "Controls overactive sweat glands\nin targeted areas.",
              face_dot: { left: "89.23%", top: "91.82%" },
              range: "$100 - $200",
              units: "10-20 units"
            }
          ],

          selectedArea: "Forehead"
        },
        Object.fromEntries(
          Object.entries(props.args).filter(([_, v]) => v !== undefined)
        )
      ),
    [props.args]
  );
  const $props = {
    ...args,
    ...variants
  };
  const __nextRouter = useNextRouter();
  const $ctx = useDataEnv?.() || {};
  const refsRef = React.useRef({});
  const $refs = refsRef.current;
  const stateSpecs = React.useMemo(
    () => [
      {
        path: "stateItems",
        type: "private",
        variableType: "array",
        initFunc: ({ $props, $state, $queries, $ctx }) =>
          (() => {
            try {
              return $props.items;
            } catch (e) {
              if (
                e instanceof TypeError ||
                e?.plasmicType === "PlasmicUndefinedDataError"
              ) {
                return [];
              }
              throw e;
            }
          })()
      },
      {
        path: "stateSelectedArea",
        type: "private",
        variableType: "text",
        initFunc: ({ $props, $state, $queries, $ctx }) =>
          (() => {
            try {
              return $props.selectedArea;
            } catch (e) {
              if (
                e instanceof TypeError ||
                e?.plasmicType === "PlasmicUndefinedDataError"
              ) {
                return undefined;
              }
              throw e;
            }
          })()
      },
      {
        path: "isShowSelectedArea",
        type: "private",
        variableType: "boolean",
        initFunc: ({ $props, $state, $queries, $ctx }) => false
      }
    ],

    [$props, $ctx, $refs]
  );
  const $state = useDollarState(stateSpecs, {
    $props,
    $ctx,
    $queries: {},
    $refs
  });
  const globalVariants = ensureGlobalVariants({
    screen: useScreenVariants_4IUcgkiijTv2()
  });
  return (
    <Stack__
      as={"section"}
      data-plasmic-name={"root"}
      data-plasmic-override={overrides.root}
      data-plasmic-root={true}
      data-plasmic-for-node={forNode}
      hasGap={true}
      className={classNames(
        projectcss.all,
        projectcss.root_reset,
        projectcss.plasmic_default_styles,
        projectcss.plasmic_mixins,
        projectcss.plasmic_tokens,
        plasmic_antd_5_hostless_css.plasmic_tokens,
        sty.root
      )}
    >
      <Stack__
        as={"div"}
        hasGap={true}
        className={classNames(projectcss.all, sty.freeBox__hd7Kk)}
      >
        <Stack__
          as={"div"}
          hasGap={true}
          className={classNames(projectcss.all, sty.freeBox__wDpZb)}
        >
          <Stack__
            as={"div"}
            hasGap={true}
            className={classNames(projectcss.all, sty.freeBox__w1XIn)}
          >
            <div
              className={classNames(
                projectcss.all,
                projectcss.__wab_text,
                sty.text__lOcF
              )}
            >
              {hasVariant(globalVariants, "screen", "mobileOnly") ? (
                <React.Fragment>
                  <span
                    className={"plasmic_default__all plasmic_default__span"}
                    style={{ color: "#080909", fontWeight: 400 }}
                  >
                    {"What Conditions/Areas \nCan Botox"}
                  </span>
                  <React.Fragment> </React.Fragment>
                  <span
                    className={"plasmic_default__all plasmic_default__span"}
                    style={{ fontStyle: "italic", color: "#D19D51" }}
                  >
                    {"Help "}
                  </span>
                  <React.Fragment>{""}</React.Fragment>
                  <span
                    className={"plasmic_default__all plasmic_default__span"}
                    style={{
                      fontStyle: "italic",
                      color: "#D19D51",
                      fontWeight: 500
                    }}
                  >
                    {"Treat"}
                  </span>
                  <React.Fragment>{""}</React.Fragment>
                  <span
                    className={"plasmic_default__all plasmic_default__span"}
                    style={{ fontStyle: "italic", color: "#D19D51" }}
                  >
                    {"?"}
                  </span>
                </React.Fragment>
              ) : (
                <React.Fragment>
                  <span
                    className={"plasmic_default__all plasmic_default__span"}
                    style={{ color: "#080909" }}
                  >
                    {"What Conditions/Areas Can Botox"}
                  </span>
                  <React.Fragment> </React.Fragment>
                  <span
                    className={"plasmic_default__all plasmic_default__span"}
                    style={{ fontStyle: "italic", color: "#D19D51" }}
                  >
                    {"Help Treat?"}
                  </span>
                </React.Fragment>
              )}
            </div>
            <div
              className={classNames(
                projectcss.all,
                projectcss.__wab_text,
                sty.text__f2R2E
              )}
            >
              {hasVariant(globalVariants, "screen", "mobileOnly")
                ? "Botox is a remarkably versatile treatment that addresses a wide range of cosmetic and therapeutic concerns on the face and body. Explore the following areas where Botox can be applied:"
                : "Botox is a remarkably versatile treatment that addresses a wide range of cosmetic and therapeutic concerns on the face and body. Explore the following areas where Botox can be applied:"}
            </div>
          </Stack__>
          <div className={classNames(projectcss.all, sty.freeBox__rz0K)}>
            <Stack__
              as={"div"}
              hasGap={true}
              className={classNames(projectcss.all, sty.freeBox__vJtHx)}
            >
              {(_par => (!_par ? [] : Array.isArray(_par) ? _par : [_par]))(
                (() => {
                  try {
                    return $props.items;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return [];
                    }
                    throw e;
                  }
                })()
              ).map((__plasmic_item_0, __plasmic_idx_0) => {
                const currentItem = __plasmic_item_0;
                const currentIndex = __plasmic_idx_0;
                return (
                  <SelectPill
                    className={classNames(
                      "__wab_instance",
                      sty.selectPill__lLmyG
                    )}
                    handleClick={async () => {
                      const $steps = {};
                      $steps["updateStateSelectedArea"] = true
                        ? (() => {
                            const actionArgs = {
                              operation: 0,
                              value: currentItem.name,
                              variable: {
                                objRoot: $state,
                                variablePath: ["stateSelectedArea"]
                              }
                            };
                            return (({
                              variable,
                              value,
                              startIndex,
                              deleteCount
                            }) => {
                              if (!variable) {
                                return;
                              }
                              const { objRoot, variablePath } = variable;
                              $stateSet(objRoot, variablePath, value);
                              return value;
                            })?.apply(null, [actionArgs]);
                          })()
                        : undefined;
                      if (
                        $steps["updateStateSelectedArea"] != null &&
                        typeof $steps["updateStateSelectedArea"] === "object" &&
                        typeof $steps["updateStateSelectedArea"].then ===
                          "function"
                      ) {
                        $steps["updateStateSelectedArea"] = await $steps[
                          "updateStateSelectedArea"
                        ];
                      }
                    }}
                    key={currentIndex}
                    selected={(() => {
                      try {
                        return currentItem.name === $state.stateSelectedArea;
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return [];
                        }
                        throw e;
                      }
                    })()}
                    value={(() => {
                      try {
                        return `${currentItem.name} ${currentItem.nameDescription}`;
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return undefined;
                        }
                        throw e;
                      }
                    })()}
                  />
                );
              })}
            </Stack__>
          </div>
        </Stack__>
        <div className={classNames(projectcss.all, sty.freeBox__nmMb)}>
          <PlasmicImg__
            alt={""}
            className={classNames(sty.img__fnGPr)}
            displayHeight={"auto"}
            displayMaxHeight={"none"}
            displayMaxWidth={"100%"}
            displayMinHeight={"0"}
            displayMinWidth={"0"}
            displayWidth={"auto"}
            loading={"lazy"}
            src={
              hasVariant(globalVariants, "screen", "mobileOnly")
                ? {
                    src: "/plasmic/image_lab_2024/images/imagePng19.png",
                    fullWidth: 686,
                    fullHeight: 978,
                    aspectRatio: undefined
                  }
                : {
                    src: "/plasmic/image_lab_2024/images/imagePng20.png",
                    fullWidth: 1300,
                    fullHeight: 1320,
                    aspectRatio: undefined
                  }
            }
          />

          {(_par => (!_par ? [] : Array.isArray(_par) ? _par : [_par]))(
            (() => {
              try {
                return $state.stateItems;
              } catch (e) {
                if (
                  e instanceof TypeError ||
                  e?.plasmicType === "PlasmicUndefinedDataError"
                ) {
                  return [];
                }
                throw e;
              }
            })()
          ).map((__plasmic_item_0, __plasmic_idx_0) => {
            const currentItem = __plasmic_item_0;
            const currentIndex = __plasmic_idx_0;
            return (
              <FaceDot
                className={classNames("__wab_instance", sty.faceDot__ma7Xj)}
                handleClick={async () => {
                  const $steps = {};
                  $steps["updateStateSelectedArea"] = true
                    ? (() => {
                        const actionArgs = {
                          variable: {
                            objRoot: $state,
                            variablePath: ["stateSelectedArea"]
                          },
                          operation: 0,
                          value: currentItem.name
                        };
                        return (({
                          variable,
                          value,
                          startIndex,
                          deleteCount
                        }) => {
                          if (!variable) {
                            return;
                          }
                          const { objRoot, variablePath } = variable;
                          $stateSet(objRoot, variablePath, value);
                          return value;
                        })?.apply(null, [actionArgs]);
                      })()
                    : undefined;
                  if (
                    $steps["updateStateSelectedArea"] != null &&
                    typeof $steps["updateStateSelectedArea"] === "object" &&
                    typeof $steps["updateStateSelectedArea"].then === "function"
                  ) {
                    $steps["updateStateSelectedArea"] = await $steps[
                      "updateStateSelectedArea"
                    ];
                  }
                }}
                key={currentIndex}
                left={(() => {
                  try {
                    return currentItem.face_dot.left;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return undefined;
                    }
                    throw e;
                  }
                })()}
                selected={(() => {
                  try {
                    return $state.stateSelectedArea === currentItem.name;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return "selected";
                    }
                    throw e;
                  }
                })()}
                top={(() => {
                  try {
                    return currentItem.face_dot.top;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return undefined;
                    }
                    throw e;
                  }
                })()}
                value={(() => {
                  try {
                    return currentItem.name;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return undefined;
                    }
                    throw e;
                  }
                })()}
              />
            );
          })}
          <AreaCard
            className={classNames("__wab_instance", sty.areaCard__hqcnV)}
            data={(() => {
              try {
                return $state.stateItems.find(
                  item => item.name === $state.stateSelectedArea
                );
              } catch (e) {
                if (
                  e instanceof TypeError ||
                  e?.plasmicType === "PlasmicUndefinedDataError"
                ) {
                  return undefined;
                }
                throw e;
              }
            })()}
            types={"fullContent"}
          />
        </div>
      </Stack__>
      <div className={classNames(projectcss.all, sty.freeBox__gbGa)}>
        <Stack__
          as={"div"}
          hasGap={true}
          className={classNames(projectcss.all, sty.freeBox__n8AqW)}
        >
          <div
            className={classNames(
              projectcss.all,
              projectcss.__wab_text,
              sty.text__ouWWp
            )}
          >
            {hasVariant(globalVariants, "screen", "mobileOnly") ? (
              <React.Fragment>
                <span
                  className={"plasmic_default__all plasmic_default__span"}
                  style={{ color: "#080909", fontWeight: 400 }}
                >
                  {"What Conditions/ Areas Can Botox "}
                </span>
                <React.Fragment>{""}</React.Fragment>
                <span
                  className={"plasmic_default__all plasmic_default__span"}
                  style={{ fontStyle: "italic", color: "#D19D51" }}
                >
                  {"Help "}
                </span>
                <React.Fragment>{""}</React.Fragment>
                <span
                  className={"plasmic_default__all plasmic_default__span"}
                  style={{
                    fontStyle: "italic",
                    color: "#D19D51",
                    fontWeight: 500
                  }}
                >
                  {"Treat"}
                </span>
                <React.Fragment>{""}</React.Fragment>
                <span
                  className={"plasmic_default__all plasmic_default__span"}
                  style={{ fontStyle: "italic", color: "#D19D51" }}
                >
                  {"?"}
                </span>
              </React.Fragment>
            ) : (
              <React.Fragment>
                <span
                  className={"plasmic_default__all plasmic_default__span"}
                  style={{ color: "#080909" }}
                >
                  {"What Conditions/Areas Can Botox"}
                </span>
                <React.Fragment> </React.Fragment>
                <span
                  className={"plasmic_default__all plasmic_default__span"}
                  style={{ fontStyle: "italic", color: "#D19D51" }}
                >
                  {"Help Treat?"}
                </span>
              </React.Fragment>
            )}
          </div>
          <div
            className={classNames(
              projectcss.all,
              projectcss.__wab_text,
              sty.text__agGRe
            )}
          >
            {hasVariant(globalVariants, "screen", "mobileOnly")
              ? "Botox is a remarkably versatile treatment that addresses a wide range of cosmetic and therapeutic concerns on the face and body. Explore the following areas where Botox can be applied:"
              : "Botox is a remarkably versatile treatment that addresses a wide range of cosmetic and therapeutic concerns on the face and body. Explore the following areas where Botox can be applied:"}
          </div>
        </Stack__>
        <div className={classNames(projectcss.all, sty.freeBox__tqnTw)}>
          <PlasmicImg__
            alt={""}
            className={classNames(sty.img__lNmPn)}
            displayHeight={"auto"}
            displayMaxHeight={"none"}
            displayMaxWidth={"100%"}
            displayMinHeight={"0"}
            displayMinWidth={"0"}
            displayWidth={"auto"}
            loading={"lazy"}
            src={
              hasVariant(globalVariants, "screen", "mobileOnly")
                ? {
                    src: "/plasmic/image_lab_2024/images/imagePng19.png",
                    fullWidth: 686,
                    fullHeight: 978,
                    aspectRatio: undefined
                  }
                : {
                    src: "/plasmic/image_lab_2024/images/imagePng20.png",
                    fullWidth: 1300,
                    fullHeight: 1320,
                    aspectRatio: undefined
                  }
            }
          />

          {(_par => (!_par ? [] : Array.isArray(_par) ? _par : [_par]))(
            (() => {
              try {
                return $state.stateItems;
              } catch (e) {
                if (
                  e instanceof TypeError ||
                  e?.plasmicType === "PlasmicUndefinedDataError"
                ) {
                  return [];
                }
                throw e;
              }
            })()
          ).map((__plasmic_item_0, __plasmic_idx_0) => {
            const currentItem = __plasmic_item_0;
            const currentIndex = __plasmic_idx_0;
            return (
              <FaceDot
                className={classNames("__wab_instance", sty.faceDot__vjgEm)}
                handleClick={async () => {
                  const $steps = {};
                  $steps["updateStateSelectedArea"] = true
                    ? (() => {
                        const actionArgs = {
                          variable: {
                            objRoot: $state,
                            variablePath: ["stateSelectedArea"]
                          },
                          operation: 0,
                          value: currentItem.name
                        };
                        return (({
                          variable,
                          value,
                          startIndex,
                          deleteCount
                        }) => {
                          if (!variable) {
                            return;
                          }
                          const { objRoot, variablePath } = variable;
                          $stateSet(objRoot, variablePath, value);
                          return value;
                        })?.apply(null, [actionArgs]);
                      })()
                    : undefined;
                  if (
                    $steps["updateStateSelectedArea"] != null &&
                    typeof $steps["updateStateSelectedArea"] === "object" &&
                    typeof $steps["updateStateSelectedArea"].then === "function"
                  ) {
                    $steps["updateStateSelectedArea"] = await $steps[
                      "updateStateSelectedArea"
                    ];
                  }
                }}
                key={currentIndex}
                left={(() => {
                  try {
                    return currentItem.face_dot.left;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return undefined;
                    }
                    throw e;
                  }
                })()}
                selected={(() => {
                  try {
                    return $state.stateSelectedArea === currentItem.name;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return "selected";
                    }
                    throw e;
                  }
                })()}
                top={(() => {
                  try {
                    return currentItem.face_dot.top;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return undefined;
                    }
                    throw e;
                  }
                })()}
                value={(() => {
                  try {
                    return currentItem.name;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return undefined;
                    }
                    throw e;
                  }
                })()}
              />
            );
          })}
          <div className={classNames(projectcss.all, sty.freeBox__eKpjI)}>
            <AreaCard
              className={classNames("__wab_instance", sty.areaCard__cpxgu)}
              data={(() => {
                try {
                  return $state.stateItems.find(
                    item => item.name === $state.stateSelectedArea
                  );
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return undefined;
                  }
                  throw e;
                }
              })()}
              types={
                hasVariant(globalVariants, "screen", "mobileOnly")
                  ? "fullContent"
                  : "fullContent"
              }
            />
          </div>
        </div>
        <div
          className={classNames(projectcss.all, sty.freeBox__mBdh4)}
          style={(() => {
            try {
              return {
                display: $state.isShowSelectedArea ? "flex" : "none"
              };
            } catch (e) {
              if (
                e instanceof TypeError ||
                e?.plasmicType === "PlasmicUndefinedDataError"
              ) {
                return undefined;
              }
              throw e;
            }
          })()}
        >
          <Stack__
            as={"div"}
            hasGap={true}
            className={classNames(projectcss.all, sty.freeBox__wmBuP)}
          >
            <div className={classNames(projectcss.all, sty.freeBox___9FPk1)}>
              <div
                className={classNames(
                  projectcss.all,
                  projectcss.__wab_text,
                  sty.text__m5Tk
                )}
              >
                {"Tap on the desired area to view detailed information."}
              </div>
              <PlasmicImg__
                alt={""}
                className={classNames(sty.img__aHdU5)}
                displayHeight={"24px"}
                displayMaxHeight={"none"}
                displayMaxWidth={"100%"}
                displayMinHeight={"0"}
                displayMinWidth={"0"}
                displayWidth={"24px"}
                loading={"lazy"}
                onClick={async event => {
                  const $steps = {};
                  $steps["updateIsShowSelectedArea"] = true
                    ? (() => {
                        const actionArgs = {
                          variable: {
                            objRoot: $state,
                            variablePath: ["isShowSelectedArea"]
                          },
                          operation: 0,
                          value: false
                        };
                        return (({
                          variable,
                          value,
                          startIndex,
                          deleteCount
                        }) => {
                          if (!variable) {
                            return;
                          }
                          const { objRoot, variablePath } = variable;
                          $stateSet(objRoot, variablePath, value);
                          return value;
                        })?.apply(null, [actionArgs]);
                      })()
                    : undefined;
                  if (
                    $steps["updateIsShowSelectedArea"] != null &&
                    typeof $steps["updateIsShowSelectedArea"] === "object" &&
                    typeof $steps["updateIsShowSelectedArea"].then ===
                      "function"
                  ) {
                    $steps["updateIsShowSelectedArea"] = await $steps[
                      "updateIsShowSelectedArea"
                    ];
                  }
                }}
                src={{
                  src: "/plasmic/image_lab_2024/images/iconSvg15.svg",
                  fullWidth: 24,
                  fullHeight: 24,
                  aspectRatio: 1
                }}
              />
            </div>
            <Stack__
              as={"div"}
              hasGap={true}
              className={classNames(projectcss.all, sty.freeBox__lE53E)}
              onClick={async event => {
                const $steps = {};
              }}
            >
              {(_par => (!_par ? [] : Array.isArray(_par) ? _par : [_par]))(
                (() => {
                  try {
                    return $props.items;
                  } catch (e) {
                    if (
                      e instanceof TypeError ||
                      e?.plasmicType === "PlasmicUndefinedDataError"
                    ) {
                      return [];
                    }
                    throw e;
                  }
                })()
              ).map((__plasmic_item_0, __plasmic_idx_0) => {
                const currentItem = __plasmic_item_0;
                const currentIndex = __plasmic_idx_0;
                return (
                  <SelectPill
                    className={classNames(
                      "__wab_instance",
                      sty.selectPill__z20WQ
                    )}
                    handleClick={async () => {
                      const $steps = {};
                      $steps["updateStateSelectedArea"] = true
                        ? (() => {
                            const actionArgs = {
                              operation: 0,
                              value: currentItem.name,
                              variable: {
                                objRoot: $state,
                                variablePath: ["stateSelectedArea"]
                              }
                            };
                            return (({
                              variable,
                              value,
                              startIndex,
                              deleteCount
                            }) => {
                              if (!variable) {
                                return;
                              }
                              const { objRoot, variablePath } = variable;
                              $stateSet(objRoot, variablePath, value);
                              return value;
                            })?.apply(null, [actionArgs]);
                          })()
                        : undefined;
                      if (
                        $steps["updateStateSelectedArea"] != null &&
                        typeof $steps["updateStateSelectedArea"] === "object" &&
                        typeof $steps["updateStateSelectedArea"].then ===
                          "function"
                      ) {
                        $steps["updateStateSelectedArea"] = await $steps[
                          "updateStateSelectedArea"
                        ];
                      }
                      $steps["updateIsShowSelectedArea"] = true
                        ? (() => {
                            const actionArgs = {
                              variable: {
                                objRoot: $state,
                                variablePath: ["isShowSelectedArea"]
                              },
                              operation: 0,
                              value: false
                            };
                            return (({
                              variable,
                              value,
                              startIndex,
                              deleteCount
                            }) => {
                              if (!variable) {
                                return;
                              }
                              const { objRoot, variablePath } = variable;
                              $stateSet(objRoot, variablePath, value);
                              return value;
                            })?.apply(null, [actionArgs]);
                          })()
                        : undefined;
                      if (
                        $steps["updateIsShowSelectedArea"] != null &&
                        typeof $steps["updateIsShowSelectedArea"] ===
                          "object" &&
                        typeof $steps["updateIsShowSelectedArea"].then ===
                          "function"
                      ) {
                        $steps["updateIsShowSelectedArea"] = await $steps[
                          "updateIsShowSelectedArea"
                        ];
                      }
                    }}
                    key={currentIndex}
                    selected={(() => {
                      try {
                        return currentItem.name === $state.stateSelectedArea;
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return [];
                        }
                        throw e;
                      }
                    })()}
                    value={(() => {
                      try {
                        return `${currentItem.name} ${currentItem.nameDescription}`;
                      } catch (e) {
                        if (
                          e instanceof TypeError ||
                          e?.plasmicType === "PlasmicUndefinedDataError"
                        ) {
                          return undefined;
                        }
                        throw e;
                      }
                    })()}
                  />
                );
              })}
            </Stack__>
          </Stack__>
        </div>
        <div className={classNames(projectcss.all, sty.freeBox__vv2Sd)}>
          <div
            className={classNames(
              projectcss.all,
              projectcss.__wab_text,
              sty.text__eNxe7
            )}
          >
            {"Selected Area:"}
          </div>
          <div
            className={classNames(
              projectcss.all,
              projectcss.__wab_text,
              sty.text__w0SNf
            )}
          >
            <React.Fragment>
              {(() => {
                try {
                  return $state.stateSelectedArea;
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return "";
                  }
                  throw e;
                }
              })()}
            </React.Fragment>
          </div>
        </div>
        <AntdButton
          data-plasmic-name={"button"}
          data-plasmic-override={overrides.button}
          className={classNames("__wab_instance", sty.button)}
          onClick={async () => {
            const $steps = {};
            $steps["updateIsShowSelectedArea"] = true
              ? (() => {
                  const actionArgs = {
                    variable: {
                      objRoot: $state,
                      variablePath: ["isShowSelectedArea"]
                    },
                    operation: 4
                  };
                  return (({ variable, value, startIndex, deleteCount }) => {
                    if (!variable) {
                      return;
                    }
                    const { objRoot, variablePath } = variable;
                    const oldValue = $stateGet(objRoot, variablePath);
                    $stateSet(objRoot, variablePath, !oldValue);
                    return !oldValue;
                  })?.apply(null, [actionArgs]);
                })()
              : undefined;
            if (
              $steps["updateIsShowSelectedArea"] != null &&
              typeof $steps["updateIsShowSelectedArea"] === "object" &&
              typeof $steps["updateIsShowSelectedArea"].then === "function"
            ) {
              $steps["updateIsShowSelectedArea"] = await $steps[
                "updateIsShowSelectedArea"
              ];
            }
          }}
        >
          <div
            className={classNames(
              projectcss.all,
              projectcss.__wab_text,
              sty.text__br6Qi
            )}
          >
            {"Select Area"}
          </div>
        </AntdButton>
      </div>
    </Stack__>
  );
}

const PlasmicDescendants = {
  root: ["root", "button"],
  button: ["button"]
};

function makeNodeComponent(nodeName) {
  const func = function (props) {
    const { variants, args, overrides } = React.useMemo(
      () =>
        deriveRenderOpts(props, {
          name: nodeName,
          descendantNames: PlasmicDescendants[nodeName],
          internalArgPropNames: PlasmicFaceSection__ArgProps,
          internalVariantPropNames: PlasmicFaceSection__VariantProps
        }),
      [props, nodeName]
    );
    return PlasmicFaceSection__RenderFunc({
      variants,
      args,
      overrides,
      forNode: nodeName
    });
  };
  if (nodeName === "root") {
    func.displayName = "PlasmicFaceSection";
  } else {
    func.displayName = `PlasmicFaceSection.${nodeName}`;
  }
  return func;
}

export const PlasmicFaceSection = Object.assign(
  // Top-level PlasmicFaceSection renders the root element
  makeNodeComponent("root"),
  {
    // Helper components rendering sub-elements
    button: makeNodeComponent("button"),
    // Metadata about props expected for PlasmicFaceSection
    internalVariantProps: PlasmicFaceSection__VariantProps,
    internalArgProps: PlasmicFaceSection__ArgProps
  }
);

export default PlasmicFaceSection;
/* prettier-ignore-end */
